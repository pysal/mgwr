<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mgwr.gwr &#8212; mgwr v2.2.1 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pysal-styles.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/_static/pysal-styles.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="icon" href="../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          mgwr</a>
        <span class="navbar-text navbar-version pull-left"><b>2.2.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for mgwr.gwr</h1><div class="highlight"><pre>
<span></span><span class="c1"># Main GWR classes</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Taylor Oshan Tayoshan@gmail.com&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span> <span class="k">as</span> <span class="n">combo</span>
<span class="kn">from</span> <span class="nn">spglm.family</span> <span class="kn">import</span> <span class="n">Gaussian</span><span class="p">,</span> <span class="n">Binomial</span><span class="p">,</span> <span class="n">Poisson</span>
<span class="kn">from</span> <span class="nn">spglm.glm</span> <span class="kn">import</span> <span class="n">GLM</span><span class="p">,</span> <span class="n">GLMResults</span>
<span class="kn">from</span> <span class="nn">spglm.iwls</span> <span class="kn">import</span> <span class="n">iwls</span><span class="p">,</span> <span class="n">_compute_betas_gwr</span>
<span class="kn">from</span> <span class="nn">spglm.utils</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">.diagnostics</span> <span class="kn">import</span> <span class="n">get_AIC</span><span class="p">,</span> <span class="n">get_AICc</span><span class="p">,</span> <span class="n">get_BIC</span><span class="p">,</span> <span class="n">corr</span>
<span class="kn">from</span> <span class="nn">.kernels</span> <span class="kn">import</span> <span class="n">Kernel</span>
<span class="kn">from</span> <span class="nn">.summary</span> <span class="kn">import</span> <span class="n">summaryModel</span><span class="p">,</span> <span class="n">summaryGLM</span><span class="p">,</span> <span class="n">summaryGWR</span><span class="p">,</span> <span class="n">summaryMGWR</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="c1"># from .sel_bw import Sel_BW</span>


<div class="viewcode-block" id="GWR"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWR.html#mgwr.gwr.GWR">[docs]</a><span class="k">class</span> <span class="nc">GWR</span><span class="p">(</span><span class="n">GLM</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Geographically weighted regression. Can currently estimate Gaussian,</span>
<span class="sd">    Poisson, and logistic models(built on a GLM framework). GWR object prepares</span>
<span class="sd">    model input. Fit method performs estimation and returns a GWRResults object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords        : array-like</span>
<span class="sd">                    n*2, collection of n sets of (x,y) coordinates of</span>
<span class="sd">                    observatons; also used as calibration locations is</span>
<span class="sd">                    &#39;points&#39; is set to None</span>

<span class="sd">    y             : array</span>
<span class="sd">                    n*1, dependent variable</span>

<span class="sd">    X             : array</span>
<span class="sd">                    n*k, independent variable, exlcuding the constant</span>

<span class="sd">    bw            : scalar</span>
<span class="sd">                    bandwidth value consisting of either a distance or N</span>
<span class="sd">                    nearest neighbors; user specified or obtained using</span>
<span class="sd">                    Sel_BW</span>

<span class="sd">    family        : family object</span>
<span class="sd">                    underlying probability model; provides</span>
<span class="sd">                    distribution-specific calculations</span>

<span class="sd">    offset        : array</span>
<span class="sd">                    n*1, the offset variable at the ith location. For Poisson model</span>
<span class="sd">                    this term is often the size of the population at risk or</span>
<span class="sd">                    the expected size of the outcome in spatial epidemiology</span>
<span class="sd">                    Default is None where Ni becomes 1.0 for all locations;</span>
<span class="sd">                    only for Poisson models</span>

<span class="sd">    sigma2_v1     : boolean</span>
<span class="sd">                    specify form of corrected denominator of sigma squared to use for</span>
<span class="sd">                    model diagnostics; Acceptable options are:</span>

<span class="sd">                    &#39;True&#39;:       n-tr(S) (defualt)</span>
<span class="sd">                    &#39;False&#39;:     n-2(tr(S)+tr(S&#39;S))</span>

<span class="sd">    kernel        : string</span>
<span class="sd">                    type of kernel function used to weight observations;</span>
<span class="sd">                    available options:</span>
<span class="sd">                    &#39;gaussian&#39;</span>
<span class="sd">                    &#39;bisquare&#39;</span>
<span class="sd">                    &#39;exponential&#39;</span>

<span class="sd">    fixed         : boolean</span>
<span class="sd">                    True for distance based kernel function and  False for</span>
<span class="sd">                    adaptive (nearest neighbor) kernel function (default)</span>

<span class="sd">    constant      : boolean</span>
<span class="sd">                    True to include intercept (default) in model and False to exclude</span>
<span class="sd">                    intercept.</span>

<span class="sd">    spherical     : boolean</span>
<span class="sd">                    True for shperical coordinates (long-lat),</span>
<span class="sd">                    False for projected coordinates (defalut).</span>
<span class="sd">    hat_matrix    : boolean</span>
<span class="sd">                    True to store full n by n hat matrix,</span>
<span class="sd">                    False to not store full hat matrix to minimize memory footprint (defalut).</span>

<span class="sd">    name_x        : list of strings</span>
<span class="sd">                    Names of independent variables for use in output</span>

<span class="sd">    n_jobs        : integer</span>
<span class="sd">                    The number of jobs (default -1) to run in parallel. -1 means using all processors.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    coords        : array-like</span>
<span class="sd">                    n*2, collection of n sets of (x,y) coordinates used for</span>
<span class="sd">                    calibration locations</span>

<span class="sd">    y             : array</span>
<span class="sd">                    n*1, dependent variable</span>

<span class="sd">    X             : array</span>
<span class="sd">                    n*k, independent variable, exlcuding the constant</span>

<span class="sd">    bw            : scalar</span>
<span class="sd">                    bandwidth value consisting of either a distance or N</span>
<span class="sd">                    nearest neighbors; user specified or obtained using</span>
<span class="sd">                    Sel_BW</span>

<span class="sd">    family        : family object</span>
<span class="sd">                    underlying probability model; provides</span>
<span class="sd">                    distribution-specific calculations</span>

<span class="sd">    offset        : array</span>
<span class="sd">                    n*1, the offset variable at the ith location. For Poisson model</span>
<span class="sd">                    this term is often the size of the population at risk or</span>
<span class="sd">                    the expected size of the outcome in spatial epidemiology</span>
<span class="sd">                    Default is None where Ni becomes 1.0 for all locations</span>

<span class="sd">    sigma2_v1     : boolean</span>
<span class="sd">                    specify form of corrected denominator of sigma squared to use for</span>
<span class="sd">                    model diagnostics; Acceptable options are:</span>

<span class="sd">                    &#39;True&#39;:       n-tr(S) (defualt)</span>
<span class="sd">                    &#39;False&#39;:     n-2(tr(S)+tr(S&#39;S))</span>

<span class="sd">    kernel        : string</span>
<span class="sd">                    type of kernel function used to weight observations;</span>
<span class="sd">                    available options:</span>
<span class="sd">                    &#39;gaussian&#39;</span>
<span class="sd">                    &#39;bisquare&#39;</span>
<span class="sd">                    &#39;exponential&#39;</span>

<span class="sd">    fixed         : boolean</span>
<span class="sd">                    True for distance based kernel function and  False for</span>
<span class="sd">                    adaptive (nearest neighbor) kernel function (default)</span>

<span class="sd">    constant      : boolean</span>
<span class="sd">                    True to include intercept (default) in model and False to exclude</span>
<span class="sd">                    intercept</span>

<span class="sd">    spherical     : boolean</span>
<span class="sd">                    True for shperical coordinates (long-lat),</span>
<span class="sd">                    False for projected coordinates (defalut).</span>

<span class="sd">    hat_matrix    : boolean</span>
<span class="sd">                    True to store full n by n hat matrix,</span>
<span class="sd">                    False to not store full hat matrix to minimize memory footprint (defalut).</span>

<span class="sd">    n             : integer</span>
<span class="sd">                    number of observations</span>

<span class="sd">    k             : integer</span>
<span class="sd">                    number of independent variables</span>

<span class="sd">    mean_y        : float</span>
<span class="sd">                    mean of y</span>

<span class="sd">    std_y         : float</span>
<span class="sd">                    standard deviation of y</span>

<span class="sd">    fit_params    : dict</span>
<span class="sd">                    parameters passed into fit method to define estimation</span>
<span class="sd">                    routine</span>

<span class="sd">    points        : array-like</span>
<span class="sd">                    n*2, collection of n sets of (x,y) coordinates used for</span>
<span class="sd">                    calibration locations instead of all observations;</span>
<span class="sd">                    defaults to None unles specified in predict method</span>

<span class="sd">    P             : array</span>
<span class="sd">                    n*k, independent variables used to make prediction;</span>
<span class="sd">                    exlcuding the constant; default to None unless specified</span>
<span class="sd">                    in predict method</span>

<span class="sd">    exog_scale    : scalar</span>
<span class="sd">                    estimated scale using sampled locations; defualt is None</span>
<span class="sd">                    unless specified in predict method</span>

<span class="sd">    exog_resid    : array-like</span>
<span class="sd">                    estimated residuals using sampled locations; defualt is None</span>
<span class="sd">                    unless specified in predict method</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    fit:            Fit a model</span>
<span class="sd">    predict:        Predict y at locations given exogenous variables</span>
<span class="sd">    df_model:       Model degrees of freedom</span>
<span class="sd">    df_resid:       Residual degrees of freedom</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    # basic model calibration</span>

<span class="sd">    &gt;&gt;&gt; import libpysal as ps</span>
<span class="sd">    &gt;&gt;&gt; from mgwr.gwr import GWR</span>
<span class="sd">    &gt;&gt;&gt; data = ps.io.open(ps.examples.get_path(&#39;GData_utm.csv&#39;))</span>
<span class="sd">    &gt;&gt;&gt; coords = list(zip(data.by_col(&#39;X&#39;), data.by_col(&#39;Y&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; y = np.array(data.by_col(&#39;PctBach&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; rural = np.array(data.by_col(&#39;PctRural&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; pov = np.array(data.by_col(&#39;PctPov&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; african_amer = np.array(data.by_col(&#39;PctBlack&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; X = np.hstack([rural, pov, african_amer])</span>
<span class="sd">    &gt;&gt;&gt; model = GWR(coords, y, X, bw=90.000, fixed=False, kernel=&#39;bisquare&#39;)</span>
<span class="sd">    &gt;&gt;&gt; results = model.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(results.params.shape)</span>
<span class="sd">    (159, 4)</span>

<span class="sd">    # predict at upsample locations</span>

<span class="sd">    &gt;&gt;&gt; index = np.arange(len(y))</span>
<span class="sd">    &gt;&gt;&gt; test = index[-10:]</span>
<span class="sd">    &gt;&gt;&gt; X_test = X[test]</span>
<span class="sd">    &gt;&gt;&gt; coords_test = np.array(coords)[test]</span>
<span class="sd">    &gt;&gt;&gt; model = GWR(coords, y, X, bw=94, fixed=False, kernel=&#39;bisquare&#39;)</span>
<span class="sd">    &gt;&gt;&gt; results = model.predict(coords_test, X_test)</span>
<span class="sd">    &gt;&gt;&gt; print(results.params.shape)</span>
<span class="sd">    (10, 4)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GWR.__init__"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWR.html#mgwr.gwr.GWR.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">coords</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span>
                 <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">bw</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">family</span><span class="p">:</span> <span class="n">Gaussian</span> <span class="o">=</span> <span class="n">Gaussian</span><span class="p">(),</span>
                 <span class="n">offset</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">sigma2_v1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">kernel</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;bisquare&#39;</span><span class="p">,</span>
                 <span class="n">fixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">constant</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">spherical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">hat_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">name_x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">GLM</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_v1</span> <span class="o">=</span> <span class="n">sigma2_v1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bw</span> <span class="o">=</span> <span class="n">bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">offset</span> <span class="o">*</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_scale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_resid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spherical</span> <span class="o">=</span> <span class="n">spherical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hat_matrix</span> <span class="o">=</span> <span class="n">hat_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span> <span class="o">=</span> <span class="n">name_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span></div>

    <span class="k">def</span> <span class="nf">_build_wi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bw</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">bw</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">wi</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed</span><span class="p">,</span>
                        <span class="n">function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>
                        <span class="n">spherical</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spherical</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unsupported kernel function  &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">return</span> <span class="n">wi</span>

    <span class="k">def</span> <span class="nf">_local_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local fitting at location i.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># local spatial weights</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="n">betas</span><span class="p">,</span> <span class="n">inv_xtx_xt</span> <span class="o">=</span> <span class="n">_compute_betas_gwr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
            <span class="n">predy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">betas</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">predy</span>
            <span class="n">influ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inv_xtx_xt</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="p">(</span><span class="n">Poisson</span><span class="p">,</span> <span class="n">Binomial</span><span class="p">)):</span>
            <span class="n">rslt</span> <span class="o">=</span> <span class="n">iwls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;ini_params&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;max_iter&#39;</span><span class="p">],</span> <span class="n">wi</span><span class="o">=</span><span class="n">wi</span><span class="p">)</span>
            <span class="n">inv_xtx_xt</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">influ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inv_xtx_xt</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">predy</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">predy</span>
            <span class="n">betas</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;lite&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">influ</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">betas</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">Si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inv_xtx_xt</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tr_STS_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Si</span> <span class="o">*</span> <span class="n">Si</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_xtx_xt</span><span class="p">,</span> <span class="n">inv_xtx_xt</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hat_matrix</span><span class="p">:</span>
            <span class="n">Si</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">influ</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">betas</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">Si</span><span class="p">,</span> <span class="n">tr_STS_i</span><span class="p">,</span> <span class="n">CCT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ini_params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0e-5</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
            <span class="n">solve</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;iwls&#39;</span><span class="p">,</span>
            <span class="n">lite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">pool</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that fits a model with a particular estimation routine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ini_betas     : array, optional</span>
<span class="sd">                        k*1, initial coefficient values, including constant.</span>
<span class="sd">                        Default is None, which calculates initial values during</span>
<span class="sd">                        estimation.</span>
<span class="sd">        tol:            float, optional</span>
<span class="sd">                        Tolerence for estimation convergence.</span>
<span class="sd">                        Default is 1.0e-5.</span>
<span class="sd">        max_iter      : integer, optional</span>
<span class="sd">                        Maximum number of iterations if convergence not</span>
<span class="sd">                        achieved. Default is 20.</span>
<span class="sd">        solve         : string, optional</span>
<span class="sd">                        Technique to solve MLE equations.</span>
<span class="sd">                        Default is &#39;iwls&#39;, meaning iteratively (</span>
<span class="sd">                        re)weighted least squares.</span>
<span class="sd">        lite          : bool, optional</span>
<span class="sd">                        Whether to estimate a lightweight GWR that</span>
<span class="sd">                        computes the minimum diagnostics needed for</span>
<span class="sd">                        bandwidth selection (could speed up</span>
<span class="sd">                        bandwidth selection for GWR) or to estimate</span>
<span class="sd">                        a full GWR. Default is False.</span>
<span class="sd">        pool          : None, deprecated and not used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">                      :</span>
<span class="sd">                        If lite=False, return a GWRResult</span>
<span class="sd">                        instance; otherwise, return a GWRResultLite</span>
<span class="sd">                        instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;ini_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ini_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;max_iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;solve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="s1">&#39;lite&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lite</span>

        <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The pool parameter is no longer used and will have no effect; </span><span class="se">\</span>
<span class="s2">                          parallelization is default and implemented using joblib instead.&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># if not parallel and using iwls: iteratively re-weighted least squares</span>
        <span class="k">if</span> <span class="n">solve</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;iwls&#39;</span><span class="p">:</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">rslt</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_fit</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

            <span class="n">rslt_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">rslt</span><span class="p">))</span>
            <span class="n">influ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">lite</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">GWRResultsLite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">influ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

            <span class="n">predy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hat_matrix</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">tr_STS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">GWRResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">CCT</span><span class="p">,</span> <span class="n">influ</span><span class="p">,</span> <span class="n">tr_STS</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                <span class="n">P</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                <span class="n">exog_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">exog_resid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">fit_params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that predicts values of the dependent variable at un-sampled</span>
<span class="sd">        locations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points        : array-like</span>
<span class="sd">                        n*2, collection of n sets of (x,y) coordinates used for</span>
<span class="sd">                        calibration prediction locations</span>
<span class="sd">        P             : array</span>
<span class="sd">                        n*k, independent variables used to make prediction;</span>
<span class="sd">                        exlcuding the constant</span>
<span class="sd">        exog_scale    : scalar</span>
<span class="sd">                        estimated scale using sampled locations; defualt is None</span>
<span class="sd">                        which estimates a model using points from &quot;coords&quot;</span>
<span class="sd">        exog_resid    : array-like</span>
<span class="sd">                        estimated residuals using sampled locations; defualt is None</span>
<span class="sd">                        which estimates a model using points from &quot;coords&quot;; if</span>
<span class="sd">                        given it must be n*1 where n is the length of coords</span>
<span class="sd">        fit_params    : dict</span>
<span class="sd">                        key-value pairs of parameters that will be passed into fit</span>
<span class="sd">                        method to define estimation routine; see fit method for more details</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exog_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">exog_resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">train_gwr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_scale</span> <span class="o">=</span> <span class="n">train_gwr</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_resid</span> <span class="o">=</span> <span class="n">train_gwr</span><span class="o">.</span><span class="n">resid_response</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">exog_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">exog_resid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_scale</span> <span class="o">=</span> <span class="n">exog_scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_resid</span> <span class="o">=</span> <span class="n">exog_resid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;exog_scale and exog_resid must both either be&#39;</span>
                             <span class="s1">&#39;None or specified&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">P</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="n">P</span>
        <span class="n">gwr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gwr</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">df_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">df_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GWRResults"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWRResults.html#mgwr.gwr.GWRResults">[docs]</a><span class="k">class</span> <span class="nc">GWRResults</span><span class="p">(</span><span class="n">GLMResults</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic class including common properties for all GWR regression models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model               : GWR object</span>
<span class="sd">                        pointer to GWR object with estimation parameters</span>

<span class="sd">    params              : array</span>
<span class="sd">                          n*k, estimated coefficients</span>

<span class="sd">    predy               : array</span>
<span class="sd">                          n*1, predicted y values</span>

<span class="sd">    S                   : array</span>
<span class="sd">                          n*n, hat matrix</span>

<span class="sd">    CCT                 : array</span>
<span class="sd">                          n*k, scaled variance-covariance matrix</span>

<span class="sd">    w                   : array</span>
<span class="sd">                          n*1, final weight used for iteratively re-weighted least</span>
<span class="sd">                          sqaures; default is None</span>

<span class="sd">    name_x        : list of strings</span>
<span class="sd">                    Names of independent variables for use in output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model               : GWR Object</span>
<span class="sd">                          points to GWR object for which parameters have been</span>
<span class="sd">                          estimated</span>

<span class="sd">    params              : array</span>
<span class="sd">                          n*k, parameter estimates</span>

<span class="sd">    predy               : array</span>
<span class="sd">                          n*1, predicted value of y</span>

<span class="sd">    y                   : array</span>
<span class="sd">                          n*1, dependent variable</span>

<span class="sd">    X                   : array</span>
<span class="sd">                          n*k, independent variable, including constant</span>

<span class="sd">    family              : family object</span>
<span class="sd">                          underlying probability model; provides</span>
<span class="sd">                          distribution-specific calculations</span>

<span class="sd">    n                   : integer</span>
<span class="sd">                          number of observations</span>

<span class="sd">    k                   : integer</span>
<span class="sd">                          number of independent variables</span>

<span class="sd">    df_model            : integer</span>
<span class="sd">                          model degrees of freedom</span>

<span class="sd">    df_resid            : integer</span>
<span class="sd">                          residual degrees of freedom</span>

<span class="sd">    offset              : array</span>
<span class="sd">                          n*1, the offset variable at the ith location.</span>
<span class="sd">                          For Poisson model this term is often the size of</span>
<span class="sd">                          the population at risk or the expected size of</span>
<span class="sd">                          the outcome in spatial epidemiology; Default is</span>
<span class="sd">                          None where Ni becomes 1.0 for all locations</span>

<span class="sd">    scale               : float</span>
<span class="sd">                          sigma squared used for subsequent computations</span>

<span class="sd">    w                   : array</span>
<span class="sd">                          n*1, final weights from iteratively re-weighted least</span>
<span class="sd">                          sqaures routine</span>

<span class="sd">    resid_response      : array</span>
<span class="sd">                          n*1, residuals of the repsonse</span>

<span class="sd">    resid_ss            : scalar</span>
<span class="sd">                          residual sum of sqaures</span>

<span class="sd">    W                   : array</span>
<span class="sd">                          n*n; spatial weights for each observation from each</span>
<span class="sd">                          calibration point</span>

<span class="sd">    S                   : array</span>
<span class="sd">                          n*n, hat matrix</span>

<span class="sd">    CCT                 : array</span>
<span class="sd">                          n*k, scaled variance-covariance matrix</span>

<span class="sd">    ENP                 : scalar</span>
<span class="sd">                          effective number of paramters, which depends on</span>
<span class="sd">                          sigma2</span>

<span class="sd">    tr_S                : float</span>
<span class="sd">                          trace of S (hat) matrix</span>

<span class="sd">    tr_STS              : float</span>
<span class="sd">                          trace of STS matrix</span>

<span class="sd">    y_bar               : array</span>
<span class="sd">                          n*1, weighted mean value of y</span>

<span class="sd">    TSS                 : array</span>
<span class="sd">                          n*1, geographically weighted total sum of squares</span>

<span class="sd">    RSS                 : array</span>
<span class="sd">                          n*1, geographically weighted residual sum of squares</span>

<span class="sd">    R2                  : float</span>
<span class="sd">                          R-squared for the entire model (1- RSS/TSS)</span>

<span class="sd">    adj_R2              : float</span>
<span class="sd">                          adjusted R-squared for the entire model</span>

<span class="sd">    aic                 : float</span>
<span class="sd">                          Akaike information criterion</span>

<span class="sd">    aicc                : float</span>
<span class="sd">                          corrected Akaike information criterion to account</span>
<span class="sd">                          to account for model complexity (smaller</span>
<span class="sd">                          bandwidths)</span>

<span class="sd">    bic                 : float</span>
<span class="sd">                          Bayesian information criterio</span>

<span class="sd">    localR2             : array</span>
<span class="sd">                          n*1, local R square</span>

<span class="sd">    sigma2              : float</span>
<span class="sd">                          sigma squared (residual variance) that has been</span>
<span class="sd">                          corrected to account for the ENP</span>

<span class="sd">    std_res             : array</span>
<span class="sd">                          n*1, standardised residuals</span>

<span class="sd">    bse                 : array</span>
<span class="sd">                          n*k, standard errors of parameters (betas)</span>

<span class="sd">    influ               : array</span>
<span class="sd">                          n*1, leading diagonal of S matrix</span>

<span class="sd">    CooksD              : array</span>
<span class="sd">                          n*1, Cook&#39;s D</span>

<span class="sd">    tvalues             : array</span>
<span class="sd">                          n*k, local t-statistics</span>

<span class="sd">    adj_alpha           : array</span>
<span class="sd">                          3*1, corrected alpha values to account for multiple</span>
<span class="sd">                          hypothesis testing for the 90%, 95%, and 99% confidence</span>
<span class="sd">                          levels; tvalues with an absolute value larger than the</span>
<span class="sd">                          corrected alpha are considered statistically</span>
<span class="sd">                          significant.</span>

<span class="sd">    deviance            : array</span>
<span class="sd">                          n*1, local model deviance for each calibration point</span>

<span class="sd">    resid_deviance      : array</span>
<span class="sd">                          n*1, local sum of residual deviance for each</span>
<span class="sd">                          calibration point</span>

<span class="sd">    llf                 : scalar</span>
<span class="sd">                          log-likelihood of the full model; see</span>
<span class="sd">                          pysal.contrib.glm.family for damily-sepcific</span>
<span class="sd">                          log-likelihoods</span>

<span class="sd">    pDev                : float</span>
<span class="sd">                          local percent of deviation accounted for; analogous to</span>
<span class="sd">                          r-squared for GLM&#39;s</span>

<span class="sd">    D2                  : float</span>
<span class="sd">                          percent deviance explained for GLM, equivaleng to R2 for</span>
<span class="sd">                          Gaussian.</span>

<span class="sd">    adj_D2              : float</span>
<span class="sd">                          adjusted percent deviance explained, equivaleng to adjusted</span>
<span class="sd">                          R2 for Gaussian.</span>

<span class="sd">    mu                  : array</span>
<span class="sd">                          n*, flat one dimensional array of predicted mean</span>
<span class="sd">                          response value from estimator</span>

<span class="sd">    fit_params          : dict</span>
<span class="sd">                          parameters passed into fit method to define estimation</span>
<span class="sd">                          routine</span>

<span class="sd">    predictions         : array</span>
<span class="sd">                          p*1, predicted values generated by calling the GWR</span>
<span class="sd">                          predict method to predict dependent variable at</span>
<span class="sd">                          unsampled points ()</span>

<span class="sd">    name_x        : list of strings</span>
<span class="sd">                    Names of independent variables for use in output</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    D2:                 pseudo R squared for GWR</span>
<span class="sd">    ENP:                effective number of parameters for GWR</span>
<span class="sd">    R2:                 R squared for GWR</span>
<span class="sd">    RSS:                residual sum of squares for GWR</span>
<span class="sd">    TSS:                total sum of squares for GWR</span>
<span class="sd">    adj_alpha:          adjusted alpha values to account for multiple testing</span>
<span class="sd">    adj_D2:             adjusted pseudo R squared for GWR</span>
<span class="sd">    adj_R2:             adjusted R squared for GWR</span>
<span class="sd">    bse:                standard errors of the betas</span>
<span class="sd">    conf_int:           confidence intervals</span>
<span class="sd">    cooksD:             Cook&#39;s D for GWR</span>
<span class="sd">    cov_params:         covariance parameters</span>
<span class="sd">    critical_tval:      critical t value</span>
<span class="sd">    filter_tvals:       filter t values based on p value</span>
<span class="sd">    get_bws_intervals:  bandwidths intervals</span>
<span class="sd">    localR2:            local R squared</span>
<span class="sd">    local_collinearity: local collinearity diagnostics</span>
<span class="sd">    pDev:               local percent of deviance accounted for</span>
<span class="sd">    sigma2:             residual variance</span>
<span class="sd">    spatial_variability: spatial variability diagnostics</span>
<span class="sd">    std_res:            standardised residuals</span>
<span class="sd">    summary:            summary of GWR model output</span>
<span class="sd">    tr_S:               trace of S (hat) matrix</span>
<span class="sd">    tvalues:            local t-statistics</span>
<span class="sd">    y_bar:              weighted mean of y</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GWRResults.__init__"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWRResults.html#mgwr.gwr.GWRResults.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">model</span><span class="p">:</span> <span class="n">GWR</span><span class="p">,</span>
                 <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">predy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">CCT</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">influ</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">tr_STS</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">name_x</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">GLMResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predy</span> <span class="o">=</span> <span class="n">predy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tr_STS</span> <span class="o">=</span> <span class="n">tr_STS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">influ</span> <span class="o">=</span> <span class="n">influ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CCT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">(</span><span class="n">CCT</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">exog_scale</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span> <span class="o">=</span> <span class="n">name_x</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>  <span class="c1"># recommend: if possible to rename the function name to avoid confusion</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">W</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not available for GWR prediction&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma2</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">cov_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">exog_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns scaled covariance parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov         : array</span>
<span class="sd">                      estimated covariance parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Scaled covariance parameters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cov</span> <span class="o">*</span> <span class="n">exog_scale</span> <span class="k">if</span> <span class="n">exog_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">tr_S</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        trace of S (hat) matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influ</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">ENP</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        effective number of parameters</span>

<span class="sd">        Defaults to tr(s) as defined in :cite:`yu:2019`</span>

<span class="sd">        but can alternatively be based on 2tr(s) - tr(STS)</span>

<span class="sd">        and the form depends on the specification of sigma2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sigma2_v1</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_STS</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">y_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        weighted mean of y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">arr_ybar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">w_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bw</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">sum_yw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">w_i</span><span class="p">)</span>
            <span class="n">arr_ybar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">sum_yw</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_i</span> <span class="o">*</span> <span class="n">off</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr_ybar</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">TSS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        geographically weighted total sum of squares</span>

<span class="sd">        Methods: p215, (9.9)</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">TSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">TSS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bw</span><span class="p">),</span>
                           <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_bar</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TSS</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">RSS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        geographically weighted residual sum of squares</span>

<span class="sd">        Methods: p215, (9.10)</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_resid</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">RSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">RSS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bw</span><span class="p">),</span>
                           <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RSS</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">localR2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        local R square</span>

<span class="sd">        Methods: p215, (9.8)</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TSS</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">RSS</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">TSS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only applicable to Gaussian&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">sigma2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        residual variance</span>

<span class="sd">        if sigma2_v1 is True: only use n-tr(S) in denominator</span>

<span class="sd">        Methods: p214, (9.6) :cite:`fotheringham_geographically_2002`</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>

<span class="sd">        and as defined in :cite:`yu:2019`</span>

<span class="sd">        if sigma2_v1 is False (v1v2): use n-2(tr(S)+tr(S&#39;S)) in denominator</span>

<span class="sd">        Methods: p55 (2.16)-(2.18) :cite:`fotheringham_geographically_2002`</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">sigma2_v1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid_ss</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># could be changed to SWSTW - nothing to test against</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_ss</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_STS</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">std_res</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        standardized residuals</span>

<span class="sd">        Methods:  p215, (9.7) :cite:`fotheringham_geographically_2002`</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">influ</span><span class="p">)))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        standard errors of Betas</span>

<span class="sd">        Methods:  p215, (2.15) and (2.21) :cite:`fotheringham_geographically_2002`</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CCT</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cooksD</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Influence: leading diagonal of S Matrix</span>

<span class="sd">        Methods: p216, (9.11) :cite:`fotheringham_geographically_2002`</span>
<span class="sd">        Fotheringham, A. S., Brunsdon, C., &amp; Charlton, M. (2002).</span>
<span class="sd">        Geographically weighted regression: the analysis of spatially varying</span>
<span class="sd">        relationships.</span>
<span class="sd">        Note: in (9.11), p should be tr(S), that is, the effective number of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_res</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">influ</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">influ</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">deviance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">ybar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_bar</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;deviance not currently used for Gaussian&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Poisson</span><span class="p">):</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">ybar</span> <span class="o">*</span> <span class="n">off</span><span class="p">))</span> <span class="o">-</span>
                                <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ybar</span> <span class="o">*</span> <span class="n">off</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Binomial</span><span class="p">):</span>
            <span class="n">dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">deviance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_bar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dev</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_deviance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;deviance not currently used for Gaussian&#39;</span><span class="p">)</span>

        <span class="c1"># off = self.offset.reshape((-1, 1)).T</span>
        <span class="c1"># y = self.y</span>
        <span class="c1"># ybar = self.y_bar</span>
        <span class="n">global_dev_res</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">resid_dev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dev_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">global_dev_res</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">dev_res</span> <span class="o">=</span> <span class="n">dev_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">dev_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dev_res</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dev_res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pDev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Local percentage of deviance accounted for. Described in the GWR4</span>
<span class="sd">        manual. Equivalent to 1 - (deviance/null deviance)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not implemented for Gaussian&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid_deviance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">deviance</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">adj_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Corrected alpha (critical) values to account for multiple testing during hypothesis</span>
<span class="sd">        testing. Includes corrected value for 90% (.1), 95% (.05), and 99%</span>
<span class="sd">        (.01) confidence levels. Correction comes from:</span>

<span class="sd">        :cite:`Silva:2016` : da Silva, A. R., &amp; Fotheringham, A. S. (2015). The Multiple Testing Issue in</span>
<span class="sd">        Geographically Weighted Regression. Geographical Analysis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.05</span><span class="p">,</span> <span class="mf">.001</span><span class="p">])</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENP</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">pe</span>

    <span class="k">def</span> <span class="nf">critical_tval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to derive the critical t-value based on given alpha</span>
<span class="sd">        that are needed for hypothesis testing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha           : scalar</span>
<span class="sd">                          critical value to determine which tvalues are</span>
<span class="sd">                          associated with statistically significant parameter</span>
<span class="sd">                          estimates. Default to None in which case the adjusted</span>
<span class="sd">                          alpha value at the 95 percent CI is automatically</span>
<span class="sd">                          used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        critical        : scalar</span>
<span class="sd">                          critical t-val based on alpha</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj_alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">critical</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">critical</span>

    <span class="k">def</span> <span class="nf">filter_tvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to set tvalues with an absolute value smaller than the</span>
<span class="sd">        absolute value of the alpha (critical) value to 0. If critical_t</span>
<span class="sd">        is supplied than it is used directly to filter. If alpha is provided</span>
<span class="sd">        than the critical t value will be derived and used to filter. If neither</span>
<span class="sd">        are critical_t nor alpha are provided, an adjusted alpha at the 95</span>
<span class="sd">        percent CI will automatically be used to define the critical t-value and</span>
<span class="sd">        used to filter. If both critical_t and alpha are supplied then the alpha</span>
<span class="sd">        value will be ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        critical_t      : scalar</span>
<span class="sd">                          critical t-value to determine whether parameters are</span>
<span class="sd">                          statistically significant</span>

<span class="sd">        alpha           : scalar</span>
<span class="sd">                          alpha value to determine which tvalues are</span>
<span class="sd">                          associated with statistically significant parameter</span>
<span class="sd">                          estimates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered       : array</span>
<span class="sd">                          n*k; new set of n tvalues for each of k variables</span>
<span class="sd">                          where absolute tvalues less than the absolute value of</span>
<span class="sd">                          alpha have been set to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># n = self.n</span>
        <span class="k">if</span> <span class="n">critical_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">critical</span> <span class="o">=</span> <span class="n">critical_t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">critical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_tval</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span> <span class="o">&lt;</span> <span class="n">critical</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">critical</span><span class="p">)</span>
        <span class="n">tvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tvalues</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">tvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">df_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">df_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_S</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tr_STS</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">normalized_cov_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_pearson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_working</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_anscombe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pearson_chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">null_deviance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">deviance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">null</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">global_deviance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">deviance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">resid_dev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deviance</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">D2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Percentage of deviance explanied. Equivalent to 1 - (deviance/null deviance)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">D2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_deviance</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_deviance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D2</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">R2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Global r-squared value for a Gaussian model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;R2 only for Gaussian&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">adj_D2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusted percentage of deviance explanied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj_D2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">D2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENP</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adj_D2</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">adj_R2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusted global r-squared for a Gaussian model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span> <span class="n">Gaussian</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_D2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;adjusted R2 only for Gaussian&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_AIC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aicc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_AICc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_BIC</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pseudoR2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">adj_pseudoR2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">use_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_bws_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes bandwidths confidence interval (CI) for GWR.</span>
<span class="sd">        The CI is based on Akaike weights and the bandwidth search algorithm used.</span>
<span class="sd">        Details are in Li et al. (2020) Annals of AAG</span>

<span class="sd">        Returns a tuple with lower and upper bound of the bw CI.</span>
<span class="sd">        e.g. (100, 300)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Get AICcs and associated bw from the last iteration of back-fitting and make a DataFrame</span>
        <span class="n">aiccs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">selector</span><span class="o">.</span><span class="n">sel_hist</span><span class="p">))[</span><span class="mi">1</span><span class="p">],</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;aicc&quot;</span><span class="p">])</span>
        <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;bw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">selector</span><span class="o">.</span><span class="n">sel_hist</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Sort DataFrame by the AICc values</span>
        <span class="n">aiccs</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;aicc&#39;</span><span class="p">])</span>

        <span class="c1"># Calculate delta AICc</span>
        <span class="n">d_aic_ak</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">aicc</span> <span class="o">-</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">aicc</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># Calculate AICc weights</span>
        <span class="n">w_aic_ak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_aic_ak</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_aic_ak</span><span class="p">))</span>
        <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;w_aic_ak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_aic_ak</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_aic_ak</span><span class="p">)</span>

        <span class="c1"># Calculate cum. AICc weights</span>
        <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;cum_w_ak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">w_aic_ak</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

        <span class="c1"># Find index where the cum weights above p-val</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aiccs</span><span class="p">[</span><span class="n">aiccs</span><span class="o">.</span><span class="n">cum_w_ak</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Get bw boundaries</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">aiccs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">interval</span>

    <span class="k">def</span> <span class="nf">local_collinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes several indicators of multicollinearity within a geographically</span>
<span class="sd">        weighted design matrix, including:</span>

<span class="sd">        local correlation coefficients (n, ((p**2) + p) / 2)</span>
<span class="sd">        local variance inflation factors (VIF) (n, p-1)</span>
<span class="sd">        local condition number (n, 1)</span>
<span class="sd">        local variance-decomposition proportions (n, p)</span>

<span class="sd">        Returns four arrays with the order and dimensions listed above where n</span>
<span class="sd">        is the number of locations used as calibrations points and p is the</span>
<span class="sd">        number of explanatory variables. Local correlation coefficient and local</span>
<span class="sd">        VIF are not calculated for constant term.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span>
        <span class="n">nvar</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">constant</span><span class="p">:</span>
            <span class="n">ncor</span> <span class="o">=</span> <span class="p">(((</span><span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">jk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combo</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nvar</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncor</span> <span class="o">=</span> <span class="p">(((</span><span class="n">nvar</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">nvar</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">nvar</span>
            <span class="n">jk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combo</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nvar</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">corr_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">ncor</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">constant</span><span class="p">:</span>
            <span class="n">vifs_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vifs_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span><span class="p">))</span>
        <span class="n">vdp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span><span class="p">))</span>
        <span class="n">vdp_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span><span class="p">,</span> <span class="n">nvar</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">):</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bw</span><span class="p">)</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="n">wi</span> <span class="o">/</span> <span class="n">sw</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">jk</span><span class="p">:</span>
                <span class="n">corr_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">k</span><span class="p">],</span>
                                               <span class="n">aweights</span><span class="o">=</span><span class="n">wi</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">constant</span><span class="p">:</span>
                <span class="n">corr_mati</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">aweights</span><span class="o">=</span><span class="n">wi</span><span class="p">))</span>
                <span class="n">vifs_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">corr_mati</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">corr_mati</span> <span class="o">=</span> <span class="n">corr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">aweights</span><span class="o">=</span><span class="n">wi</span><span class="p">))</span>
                <span class="n">vifs_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">corr_mati</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">((</span><span class="n">nvar</span><span class="p">))))</span>

            <span class="n">xw</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">wi</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">sxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xw</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">sxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">xw</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">sxw</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">svdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">sxw</span><span class="p">)</span>
            <span class="n">vdp_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">svdx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">phi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">pi_ij</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vdp_pi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pi_ij</span>

        <span class="n">local_CN</span> <span class="o">=</span> <span class="n">vdp_idx</span><span class="p">[:,</span> <span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">VDP</span> <span class="o">=</span> <span class="n">vdp_pi</span><span class="p">[:,</span> <span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">corr_mat</span><span class="p">,</span> <span class="n">vifs_mat</span><span class="p">,</span> <span class="n">local_CN</span><span class="p">,</span> <span class="n">VDP</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spatial_variability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">n_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to compute a Monte Carlo test of spatial variability for each</span>
<span class="sd">        estimated coefficient surface.</span>

<span class="sd">        WARNING: This test is very computationally demanding!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        selector        : sel_bw object</span>
<span class="sd">                          should be the sel_bw object used to select a bandwidth</span>
<span class="sd">                          for the gwr model that produced the surfaces that are</span>
<span class="sd">                          being tested for spatial variation</span>

<span class="sd">        n_iters         : int</span>
<span class="sd">                          the number of Monte Carlo iterations to include for</span>
<span class="sd">                          the tests of spatial variability.</span>

<span class="sd">        seed            : int</span>
<span class="sd">                          optional parameter to select a custom seed to ensure</span>
<span class="sd">                          stochastic results are replicable. Default is none</span>
<span class="sd">                          which automatically sets the seed to 5536</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        p values        : list</span>
<span class="sd">                          a list of psuedo p-values that correspond to the model</span>
<span class="sd">                          parameter surfaces. Allows us to assess the</span>
<span class="sd">                          probability of obtaining the observed spatial</span>
<span class="sd">                          variation of a given surface by random chance.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_sel</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
        <span class="n">temp_gwr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">5536</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">fit_params</span> <span class="o">=</span> <span class="n">temp_gwr</span><span class="o">.</span><span class="n">fit_params</span>
        <span class="n">search_params</span> <span class="o">=</span> <span class="n">temp_sel</span><span class="o">.</span><span class="n">search_params</span>
        <span class="c1"># kernel = temp_gwr.kernel</span>
        <span class="c1"># fixed = temp_gwr.fixed</span>

        <span class="c1"># X = self.X[:, 1:] if self.model.constant else self.X</span>

        <span class="n">init_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">SDs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># if they have it, let users have a progress bar</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># otherwise, just passthrough the range</span>
                <span class="k">return</span> <span class="n">x</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_iters</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Testing&#39;</span><span class="p">):</span>
            <span class="n">temp_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">temp_sel</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">temp_coords</span>
            <span class="n">temp_bw</span> <span class="o">=</span> <span class="n">temp_sel</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">**</span><span class="n">search_params</span><span class="p">)</span>
            <span class="n">temp_gwr</span><span class="o">.</span><span class="n">bw</span> <span class="o">=</span> <span class="n">temp_bw</span>
            <span class="n">temp_gwr</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">temp_coords</span>
            <span class="n">temp_params</span> <span class="o">=</span> <span class="n">temp_gwr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_params</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="n">temp_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">temp_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">SDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_sd</span><span class="p">)</span>

        <span class="n">p_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SDs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">init_sd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_iters</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">p_vals</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">P</span>
        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;predictions only avaialble if predict&#39;</span>
                            <span class="s1">&#39;method is previously called on GWR model&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">predictions</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out GWR summary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        as_str        : bool</span>
<span class="sd">                        optional parameters to specify that summary results</span>
<span class="sd">                        should be returned as str and not printed to stdout</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        summary        : Optional[str]</span>
<span class="sd">                        optional GWR summary string if `as_str` is True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">summaryModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">summaryGLM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">summaryGWR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">summary</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GWRResultsLite"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWRResultsLite.html#mgwr.gwr.GWRResultsLite">[docs]</a><span class="k">class</span> <span class="nc">GWRResultsLite</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lightweight GWR that computes the minimum diagnostics needed for bandwidth</span>
<span class="sd">    selection.</span>

<span class="sd">    See FastGWR,Li et al., 2019, IJGIS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model               : GWR object</span>
<span class="sd">                        pointer to GWR object with estimation parameters</span>

<span class="sd">    resid               : array</span>
<span class="sd">                        n*1, residuals of the repsonse</span>

<span class="sd">    influ               : array</span>
<span class="sd">                        n*1, leading diagonal of S matrix</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tr_S                : float</span>
<span class="sd">                        trace of S (hat) matrix</span>

<span class="sd">    llf                 : scalar</span>
<span class="sd">                        log-likelihood of the full model; see</span>
<span class="sd">                        pysal.contrib.glm.family for damily-sepcific</span>
<span class="sd">                        log-likelihoods</span>

<span class="sd">    mu                  : array</span>
<span class="sd">                        n*, flat one dimensional array of predicted mean</span>
<span class="sd">                        response value from estimator</span>

<span class="sd">    resid_ss            : scalar</span>
<span class="sd">                          residual sum of sqaures</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GWRResultsLite.__init__"><a class="viewcode-back" href="../../generated/mgwr.gwr.GWRResultsLite.html#mgwr.gwr.GWRResultsLite.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">model</span><span class="p">:</span> <span class="n">GWR</span><span class="p">,</span>
                 <span class="n">resid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">influ</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">family</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">influ</span> <span class="o">=</span> <span class="n">influ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span> <span class="o">=</span> <span class="n">resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">tr_S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influ</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">mu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">predy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid_response</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>


<div class="viewcode-block" id="MGWR"><a class="viewcode-back" href="../../generated/mgwr.gwr.MGWR.html#mgwr.gwr.MGWR">[docs]</a><span class="k">class</span> <span class="nc">MGWR</span><span class="p">(</span><span class="n">GWR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiscale GWR estimation and inference.</span>
<span class="sd">    See :cite:`Fotheringham:2017` :cite:`yu:2019`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords        : array-like</span>
<span class="sd">                    n*2, collection of n sets of (x,y) coordinates of</span>
<span class="sd">                    observatons; also used as calibration locations is</span>
<span class="sd">                    &#39;points&#39; is set to None</span>

<span class="sd">    y             : array</span>
<span class="sd">                    n*1, dependent variable</span>

<span class="sd">    X             : array</span>
<span class="sd">                    n*k, independent variable, exlcuding the constant</span>

<span class="sd">    selector      : sel_bw object</span>
<span class="sd">                    valid sel_bw object that has successfully called</span>
<span class="sd">                    the &quot;search&quot; method. This parameter passes on</span>
<span class="sd">                    information from GAM model estimation including optimal</span>
<span class="sd">                    bandwidths.</span>

<span class="sd">    family        : family object</span>
<span class="sd">                    underlying probability model; provides</span>
<span class="sd">                    distribution-specific calculations</span>

<span class="sd">    sigma2_v1     : boolean</span>
<span class="sd">                    specify form of corrected denominator of sigma squared to use for</span>
<span class="sd">                    model diagnostics; Acceptable options are:</span>

<span class="sd">                    &#39;True&#39;:       n-tr(S) (defualt)</span>
<span class="sd">                    &#39;False&#39;:     n-2(tr(S)+tr(S&#39;S))</span>

<span class="sd">    kernel        : string</span>
<span class="sd">                    type of kernel function used to weight observations;</span>
<span class="sd">                    available options:</span>
<span class="sd">                    &#39;gaussian&#39;</span>
<span class="sd">                    &#39;bisquare&#39;</span>
<span class="sd">                    &#39;exponential&#39;</span>

<span class="sd">    fixed         : boolean</span>
<span class="sd">                    True for distance based kernel function and  False for</span>
<span class="sd">                    adaptive (nearest neighbor) kernel function (default)</span>

<span class="sd">    constant      : boolean</span>
<span class="sd">                    True to include intercept (default) in model and False to exclude</span>
<span class="sd">                    intercept.</span>

<span class="sd">    spherical     : boolean</span>
<span class="sd">                    True for spherical coordinates (long-lat),</span>
<span class="sd">                    False for projected coordinates (defalut).</span>
<span class="sd">    hat_matrix    : boolean</span>
<span class="sd">                    True for computing and storing covariate-specific</span>
<span class="sd">                    hat matrices R (n,n,k) and model hat matrix S (n,n).</span>
<span class="sd">                    False (default) for computing MGWR inference on the fly.</span>

<span class="sd">    name_x        : list of strings</span>
<span class="sd">                    Names of independent variables for use in output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    coords        : array-like</span>
<span class="sd">                    n*2, collection of n sets of (x,y) coordinates of</span>
<span class="sd">                    observatons; also used as calibration locations is</span>
<span class="sd">                    &#39;points&#39; is set to None</span>

<span class="sd">    y             : array</span>
<span class="sd">                    n*1, dependent variable</span>

<span class="sd">    X             : array</span>
<span class="sd">                    n*k, independent variable, exlcuding the constant</span>

<span class="sd">    selector      : sel_bw object</span>
<span class="sd">                    valid sel_bw object that has successfully called</span>
<span class="sd">                    the &quot;search&quot; method. This parameter passes on</span>
<span class="sd">                    information from GAM model estimation including optimal</span>
<span class="sd">                    bandwidths.</span>

<span class="sd">    bw            : array-like</span>
<span class="sd">                    collection of bandwidth values consisting of either a distance or N</span>
<span class="sd">                    nearest neighbors; user specified or obtained using</span>
<span class="sd">                    Sel_BW with fb=True. Order of values should the same as</span>
<span class="sd">                    the order of columns associated with X</span>

<span class="sd">    family        : family object</span>
<span class="sd">                    underlying probability model; provides</span>
<span class="sd">                    distribution-specific calculations</span>

<span class="sd">    sigma2_v1     : boolean</span>
<span class="sd">                    specify form of corrected denominator of sigma squared to use for</span>
<span class="sd">                    model diagnostics; Acceptable options are:</span>

<span class="sd">                    &#39;True&#39;:       n-tr(S) (defualt)</span>
<span class="sd">                    &#39;False&#39;:     n-2(tr(S)+tr(S&#39;S))</span>

<span class="sd">    kernel        : string</span>
<span class="sd">                    type of kernel function used to weight observations;</span>
<span class="sd">                    available options:</span>
<span class="sd">                    &#39;gaussian&#39;</span>
<span class="sd">                    &#39;bisquare&#39;</span>
<span class="sd">                    &#39;exponential&#39;</span>

<span class="sd">    fixed         : boolean</span>
<span class="sd">                    True for distance based kernel function and  False for</span>
<span class="sd">                    adaptive (nearest neighbor) kernel function (default)</span>

<span class="sd">    constant      : boolean</span>
<span class="sd">                    True to include intercept (default) in model and False to exclude</span>
<span class="sd">                    intercept.</span>

<span class="sd">    spherical     : boolean</span>
<span class="sd">                    True for shperical coordinates (long-lat),</span>
<span class="sd">                    False for projected coordinates (defalut).</span>

<span class="sd">    n             : integer</span>
<span class="sd">                    number of observations</span>

<span class="sd">    k             : integer</span>
<span class="sd">                    number of independent variables</span>

<span class="sd">    mean_y        : float</span>
<span class="sd">                    mean of y</span>

<span class="sd">    std_y         : float</span>
<span class="sd">                    standard deviation of y</span>

<span class="sd">    fit_params    : dict</span>
<span class="sd">                    parameters passed into fit method to define estimation</span>
<span class="sd">                    routine</span>

<span class="sd">    W             : array-like</span>
<span class="sd">                    list of n*n arrays, spatial weights matrices for weighting all</span>
<span class="sd">                    observations from each calibration point: one for each</span>
<span class="sd">                    covariate (k)</span>

<span class="sd">    name_x        : list of strings</span>
<span class="sd">                    Names of independent variables for use in output</span>

<span class="sd">    n_jobs        : integer</span>
<span class="sd">                    The number of jobs (default 1) to run in parallel. -1 means using all processors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    # basic model calibration</span>

<span class="sd">    &gt;&gt;&gt; import libpysal as ps</span>
<span class="sd">    &gt;&gt;&gt; from mgwr.gwr import MGWR</span>
<span class="sd">    &gt;&gt;&gt; from mgwr.sel_bw import Sel_BW</span>
<span class="sd">    &gt;&gt;&gt; data = ps.io.open(ps.examples.get_path(&#39;GData_utm.csv&#39;))</span>
<span class="sd">    &gt;&gt;&gt; coords = list(zip(data.by_col(&#39;X&#39;), data.by_col(&#39;Y&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; y = np.array(data.by_col(&#39;PctBach&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; rural = np.array(data.by_col(&#39;PctRural&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; fb = np.array(data.by_col(&#39;PctFB&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; african_amer = np.array(data.by_col(&#39;PctBlack&#39;)).reshape((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; X = np.hstack([fb, african_amer, rural])</span>
<span class="sd">    &gt;&gt;&gt; X = (X - X.mean(axis=0)) / X.std(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; y = (y - y.mean(axis=0)) / y.std(axis=0)</span>
<span class="sd">    &gt;&gt;&gt; selector = Sel_BW(coords, y, X, multi=True)</span>
<span class="sd">    &gt;&gt;&gt; selector.search(multi_bw_min=[2])</span>
<span class="sd">    [92.0, 101.0, 136.0, 158.0]</span>
<span class="sd">    &gt;&gt;&gt; model = MGWR(coords, y, X, selector, fixed=False, kernel=&#39;bisquare&#39;, sigma2_v1=True)</span>
<span class="sd">    &gt;&gt;&gt; results = model.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(results.params.shape)</span>
<span class="sd">    (159, 4)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MGWR.__init__"><a class="viewcode-back" href="../../generated/mgwr.gwr.MGWR.html#mgwr.gwr.MGWR.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">coords</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span>
                 <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">selector</span><span class="p">,</span>
                 <span class="n">sigma2_v1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">kernel</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;bisquare&#39;</span><span class="p">,</span>
                 <span class="n">fixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">constant</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">spherical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">hat_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">name_x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">bw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># final set of bandwidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bws_history</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">bw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># bws history in backfitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bw_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">bw_init</span>  <span class="c1"># initialization bandiwdth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">Gaussian</span><span class="p">()</span>  <span class="c1"># manually set since we only support Gassian MGWR for now</span>

        <span class="n">GWR</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw_init</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span>
                     <span class="n">sigma2_v1</span><span class="o">=</span><span class="n">sigma2_v1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">,</span>
                     <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">,</span> <span class="n">spherical</span><span class="o">=</span><span class="n">spherical</span><span class="p">,</span>
                     <span class="n">hat_matrix</span><span class="o">=</span><span class="n">hat_matrix</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma2_v1</span> <span class="o">=</span> <span class="n">sigma2_v1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_resid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_scale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span> <span class="o">=</span> <span class="n">name_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span></div>

    <span class="k">def</span> <span class="nf">_chunk_compute_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute MGWR inference by chunks to reduce memory footprint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="n">n_chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_chunks</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">n_chunks</span><span class="p">)))</span>
        <span class="n">ENP_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
        <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>

        <span class="n">chunk_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="n">chunk_id</span> <span class="o">*</span> <span class="n">chunk_size</span><span class="p">:(</span><span class="n">chunk_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                                   <span class="n">chunk_size</span><span class="p">]</span>
        <span class="n">init_pR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">)))</span>
        <span class="n">init_pR</span><span class="p">[</span><span class="n">chunk_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">))</span>
        <span class="n">pR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">),</span>
                       <span class="n">k</span><span class="p">))</span>  <span class="c1"># partial R: n by chunk_size by k</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw_init</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">xT</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">wi</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">xT</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">),</span> <span class="n">xT</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">init_pR</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">pR</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">err</span> <span class="o">=</span> <span class="n">init_pR</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># n by chunk_size</span>

        <span class="k">for</span> <span class="n">iter_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bws_history</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">pRj_old</span> <span class="o">=</span> <span class="n">pR</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">err</span>
                <span class="n">Xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">n_chunks_Aj</span> <span class="o">=</span> <span class="n">n_chunks</span>
                <span class="n">chunk_size_Aj</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">n_chunks_Aj</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">chunk_Aj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks_Aj</span><span class="p">):</span>
                    <span class="n">chunk_index_Aj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="n">chunk_Aj</span> <span class="o">*</span> <span class="n">chunk_size_Aj</span><span class="p">:(</span>
                        <span class="n">chunk_Aj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size_Aj</span><span class="p">]</span>
                    <span class="n">pAj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_index_Aj</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_index_Aj</span><span class="p">)):</span>
                        <span class="n">index</span> <span class="o">=</span> <span class="n">chunk_index_Aj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">wi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bws_history</span><span class="p">[</span><span class="n">iter_i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                        <span class="n">xw</span> <span class="o">=</span> <span class="n">Xj</span> <span class="o">*</span> <span class="n">wi</span>
                        <span class="n">pAj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Xj</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xw</span> <span class="o">*</span> <span class="n">Xj</span><span class="p">)</span> <span class="o">*</span> <span class="n">xw</span>
                    <span class="n">pR</span><span class="p">[</span><span class="n">chunk_index_Aj</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pAj</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pRj_old</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">pRj_old</span> <span class="o">-</span> <span class="n">pR</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">CCT</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">((</span><span class="n">pR</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk_index</span><span class="p">)):</span>
            <span class="n">ENP_j</span> <span class="o">+=</span> <span class="n">pR</span><span class="p">[</span><span class="n">chunk_index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">ENP_j</span><span class="p">,</span> <span class="n">CCT</span><span class="p">,</span> <span class="n">pR</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hat_matrix</span> <span class="k">else</span> <span class="p">(</span><span class="n">ENP_j</span><span class="p">,</span> <span class="n">CCT</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute MGWR inference by chunk to reduce memory footprint.</span>
<span class="sd">        See Li and Fotheringham, 2020, IJGIS.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        n_chunks      : integer, optional</span>
<span class="sd">                        A number of chunks parameter to reduce memory usage.</span>
<span class="sd">                        e.g. n_chunks=2 should reduce overall memory usage by 2.</span>

<span class="sd">        pool          : None, deprecated and not used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">                      : MGWRResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">params</span>
        <span class="n">predy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tqdm.autonotebook</span> <span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># progress bar</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># otherwise, just passthrough the range</span>
                <span class="k">return</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The pool parameter is no longer used and will have no effect; </span><span class="se">\</span>
<span class="s2">                          parallelization is default and implemented using joblib instead.&quot;</span><span class="p">,</span>
                          <span class="ne">RuntimeWarning</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">max_processors</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_chunks</span> <span class="o">=</span> <span class="n">max_processors</span> <span class="o">*</span> <span class="n">n_chunks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">*</span> <span class="n">n_chunks</span>

        <span class="c1"># Using joblib for parallel processing with a tqdm progress bar</span>
        <span class="n">rslt</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_compute_R</span><span class="p">)(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chunks</span><span class="p">)),</span>
                    <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chunks</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Inference&#39;</span><span class="p">)</span>

        <span class="n">rslt_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">rslt</span><span class="p">))</span>
        <span class="n">ENP_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">rslt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hat_matrix</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">MGWRResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">CCT</span><span class="p">,</span> <span class="n">ENP_j</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exact_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A closed-form solution to MGWR estimates and inference,</span>
<span class="sd">        the backfitting in self.fit() will converge to this solution.</span>

<span class="sd">        Note: this would require large memory when n &gt; 5,000.</span>
<span class="sd">        See Li and Fotheringham, 2020, IJGIS, pg.4.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">                      : MGWRResults</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
            <span class="n">Aj</span> <span class="o">=</span> <span class="n">GWR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                     <span class="n">bw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bws</span><span class="p">[</span><span class="n">j1</span><span class="p">],</span>
                     <span class="n">hat_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">constant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">S</span>
            <span class="n">Pj</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j1</span> <span class="o">==</span> <span class="n">j2</span><span class="p">:</span>
                    <span class="n">Pj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Pj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Aj</span><span class="p">)</span>
            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pj</span><span class="p">)</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Aj</span><span class="p">])</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ENP_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">predy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="n">CCT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
            <span class="n">CCT</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">MGWRResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="n">CCT</span><span class="p">,</span> <span class="n">ENP_j</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Not implemented.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MGWRResults"><a class="viewcode-back" href="../../generated/mgwr.gwr.MGWRResults.html#mgwr.gwr.MGWRResults">[docs]</a><span class="k">class</span> <span class="nc">MGWRResults</span><span class="p">(</span><span class="n">GWRResults</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class including common properties for a MGWR model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model               : MGWR object</span>
<span class="sd">                          pointer to MGWR object with estimation parameters</span>

<span class="sd">    params              : array</span>
<span class="sd">                          n*k, estimated coefficients</span>

<span class="sd">    predy               : array</span>
<span class="sd">                          n*1, predicted y values</span>

<span class="sd">    S                   : array</span>
<span class="sd">                          n*n, model hat matrix (if MGWR(hat_matrix=True))</span>

<span class="sd">    R                   : array</span>
<span class="sd">                          n*n*k, covariate-specific hat matrices (if MGWR(hat_matrix=True))</span>

<span class="sd">    CCT                 : array</span>
<span class="sd">                          n*k, scaled variance-covariance matrix</span>

<span class="sd">    w                   : array</span>
<span class="sd">                          n*1, final weight used for iteratively re-weighted least</span>
<span class="sd">                          sqaures; default is None</span>

<span class="sd">    name_x              : list of strings</span>
<span class="sd">                           Names of independent variables for use in output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model               : GWR Object</span>
<span class="sd">                          points to GWR object for which parameters have been</span>
<span class="sd">                          estimated</span>

<span class="sd">    params              : array</span>
<span class="sd">                          n*k, parameter estimates</span>

<span class="sd">    predy               : array</span>
<span class="sd">                          n*1, predicted value of y</span>

<span class="sd">    y                   : array</span>
<span class="sd">                          n*1, dependent variable</span>

<span class="sd">    X                   : array</span>
<span class="sd">                          n*k, independent variable, including constant</span>

<span class="sd">    family              : family object</span>
<span class="sd">                          underlying probability model; provides</span>
<span class="sd">                          distribution-specific calculations</span>

<span class="sd">    n                   : integer</span>
<span class="sd">                          number of observations</span>

<span class="sd">    k                   : integer</span>
<span class="sd">                          number of independent variables</span>

<span class="sd">    df_model            : integer</span>
<span class="sd">                          model degrees of freedom</span>

<span class="sd">    df_resid            : integer</span>
<span class="sd">                          residual degrees of freedom</span>

<span class="sd">    scale               : float</span>
<span class="sd">                          sigma squared used for subsequent computations</span>

<span class="sd">    w                   : array</span>
<span class="sd">                          n*1, final weights from iteratively re-weighted least</span>
<span class="sd">                          sqaures routine</span>

<span class="sd">    resid_response      : array</span>
<span class="sd">                          n*1, residuals of the repsonse</span>

<span class="sd">    resid_ss            : scalar</span>
<span class="sd">                          residual sum of sqaures</span>

<span class="sd">    W                   : array-like</span>
<span class="sd">                          list of n*n arrays, spatial weights matrices for weighting all</span>
<span class="sd">                          observations from each calibration point: one for each</span>
<span class="sd">                          covariate (k)</span>

<span class="sd">    S                   : array</span>
<span class="sd">                          n*n, model hat matrix (if MGWR(hat_matrix=True))</span>

<span class="sd">    R                   : array</span>
<span class="sd">                          n*n*k, covariate-specific hat matrices (if MGWR(hat_matrix=True))</span>

<span class="sd">    CCT                 : array</span>
<span class="sd">                          n*k, scaled variance-covariance matrix</span>

<span class="sd">    ENP                 : scalar</span>
<span class="sd">                          effective number of paramters, which depends on</span>
<span class="sd">                          sigma2, for the entire model</span>

<span class="sd">    ENP_j               : array-like</span>
<span class="sd">                          effective number of paramters, which depends on</span>
<span class="sd">                          sigma2, for each covariate in the model</span>

<span class="sd">    adj_alpha           : array</span>
<span class="sd">                          3*1, corrected alpha values to account for multiple</span>
<span class="sd">                          hypothesis testing for the 90%, 95%, and 99% confidence</span>
<span class="sd">                          levels; tvalues with an absolute value larger than the</span>
<span class="sd">                          corrected alpha are considered statistically</span>
<span class="sd">                          significant.</span>

<span class="sd">    adj_alpha_j         : array</span>
<span class="sd">                          k*3, corrected alpha values to account for multiple</span>
<span class="sd">                          hypothesis testing for the 90%, 95%, and 99% confidence</span>
<span class="sd">                          levels; tvalues with an absolute value larger than the</span>
<span class="sd">                          corrected alpha are considered statistically</span>
<span class="sd">                          significant. A set of alpha calues is computed for</span>
<span class="sd">                          each covariate in the model.</span>

<span class="sd">    tr_S                : float</span>
<span class="sd">                          trace of S (hat) matrix</span>

<span class="sd">    tr_STS              : float</span>
<span class="sd">                          trace of STS matrix</span>

<span class="sd">    R2                  : float</span>
<span class="sd">                          R-squared for the entire model (1- RSS/TSS)</span>

<span class="sd">    adj_R2              : float</span>
<span class="sd">                          adjusted R-squared for the entire model</span>

<span class="sd">    aic                 : float</span>
<span class="sd">                          Akaike information criterion</span>

<span class="sd">    aicc                : float</span>
<span class="sd">                          corrected Akaike information criterion to account</span>
<span class="sd">                          to account for model complexity (smaller</span>
<span class="sd">                          bandwidths)</span>

<span class="sd">    bic                 : float</span>
<span class="sd">                          Bayesian information criterio</span>

<span class="sd">    sigma2              : float</span>
<span class="sd">                          sigma squared (residual variance) that has been</span>
<span class="sd">                          corrected to account for the ENP</span>

<span class="sd">    std_res             : array</span>
<span class="sd">                          n*1, standardised residuals</span>

<span class="sd">    bse                 : array</span>
<span class="sd">                          n*k, standard errors of parameters (betas)</span>

<span class="sd">    influ               : array</span>
<span class="sd">                          n*1, leading diagonal of S matrix</span>

<span class="sd">    CooksD              : array</span>
<span class="sd">                          n*1, Cook&#39;s D</span>

<span class="sd">    tvalues             : array</span>
<span class="sd">                          n*k, local t-statistics</span>

<span class="sd">    llf                 : scalar</span>
<span class="sd">                          log-likelihood of the full model; see</span>
<span class="sd">                          pysal.contrib.glm.family for damily-sepcific</span>
<span class="sd">                          log-likelihoods</span>

<span class="sd">    mu                  : array</span>
<span class="sd">                          n*, flat one dimensional array of predicted mean</span>
<span class="sd">                          response value from estimator</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MGWRResults.__init__"><a class="viewcode-back" href="../../generated/mgwr.gwr.MGWRResults.html#mgwr.gwr.MGWRResults.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">model</span><span class="p">:</span> <span class="n">GWR</span><span class="p">,</span>
                 <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">predy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">CCT</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">ENP_j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">R</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                 <span class="n">name_x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENP_j</span> <span class="o">=</span> <span class="n">ENP_j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
        <span class="n">GWRResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predy</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">CCT</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">hat_matrix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predy</span> <span class="o">=</span> <span class="n">predy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_x</span> <span class="o">=</span> <span class="n">name_x</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">tr_S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ENP_j</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># TODO: change function name to avoid user confusion</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bw_j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">bws</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_build_wi</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bw_j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)])</span>
            <span class="n">Ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ws</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">adj_alpha_j</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Corrected alpha (critical) values to account for multiple testing during hypothesis</span>
<span class="sd">        testing. Includes corrected value for 90% (.1), 95% (.05), and 99%</span>
<span class="sd">        (.01) confidence levels. Correction comes from:</span>

<span class="sd">        :cite:`Silva:2016` : da Silva, A. R., &amp; Fotheringham, A. S. (2015). The Multiple Testing Issue in</span>
<span class="sd">        Geographically Weighted Regression. Geographical Analysis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.05</span><span class="p">,</span> <span class="mf">.001</span><span class="p">])</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ENP_j</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">pe</span>

    <span class="k">def</span> <span class="nf">critical_tval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to derive the critial t-value based on given alpha</span>
<span class="sd">        that are needed for hypothesis testing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha           : scalar</span>
<span class="sd">                          critical value to determine which tvalues are</span>
<span class="sd">                          associated with statistically significant parameter</span>
<span class="sd">                          estimates. Default to None in which case the adjusted</span>
<span class="sd">                          alpha value at the 95 percent CI is automatically</span>
<span class="sd">                          used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        critical        : scalar</span>
<span class="sd">                          critical t-val based on alpha</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj_alpha_j</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">critical</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">critical</span>

    <span class="k">def</span> <span class="nf">filter_tvals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to set tvalues with an absolute value smaller than the</span>
<span class="sd">        absolute value of the alpha (critical) value to 0. If critical_t</span>
<span class="sd">        is supplied than it is used directly to filter. If alpha is provided</span>
<span class="sd">        than the critical t value will be derived and used to filter. If neither</span>
<span class="sd">        are critical_t nor alpha are provided, an adjusted alpha at the 95</span>
<span class="sd">        percent CI will automatically be used to define the critical t-value and</span>
<span class="sd">        used to filter. If both critical_t and alpha are supplied then the alpha</span>
<span class="sd">        value will be ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        critical        : scalar</span>
<span class="sd">                          critical t-value to determine whether parameters are</span>
<span class="sd">                          statistically significant</span>

<span class="sd">        alpha           : scalar</span>
<span class="sd">                          alpha value to determine which tvalues are</span>
<span class="sd">                          associated with statistically significant parameter</span>
<span class="sd">                          estimates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered       : array</span>
<span class="sd">                          n*k; new set of n tvalues for each of k variables</span>
<span class="sd">                          where absolute tvalues less than the absolute value of</span>
<span class="sd">                          alpha have been set to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># n = self.n   # Not used</span>
        <span class="k">if</span> <span class="n">critical_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">critical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">critical_t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">critical_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">critical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_tval</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">critical_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">critical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_tval</span><span class="p">()</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span> <span class="o">&lt;</span> <span class="n">critical</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">critical</span><span class="p">)</span>
        <span class="n">tvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tvalues</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">tvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">RSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Not yet implemented for multiple bandwidths&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">TSS</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Not yet implemented for multiple bandwidths&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">localR2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Not yet implemented for multiple bandwidths&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">y_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Not yet implemented for multiple bandwidths&#39;</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">predictions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not yet implemented for MGWR&#39;</span><span class="p">)</span>

    <span class="c1"># Function for getting BWs intervals</span>
    <span class="k">def</span> <span class="nf">get_bws_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes bandwidths confidence intervals (CIs) for MGWR.</span>
<span class="sd">        The CIs are based on Akaike weights and the bandwidth search algorithm used.</span>
<span class="sd">        Details are in Li et al. (2020) Annals of AAG</span>

<span class="sd">        Returns a list of confidence intervals. e.g. [(40, 60), (100, 180), (150, 300)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
            <span class="c1"># Get AICcs and associated bw from the last iteration of back-fitting and make a DataFrame</span>
            <span class="n">aiccs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">selector</span><span class="o">.</span><span class="n">sel_hist</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">]))[</span><span class="mi">1</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;aicc&quot;</span><span class="p">])</span>
            <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;bw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">selector</span><span class="o">.</span><span class="n">sel_hist</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Sort DataFrame by the AICc values</span>
            <span class="n">aiccs</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;aicc&#39;</span><span class="p">])</span>

            <span class="c1"># Calculate delta AICc</span>
            <span class="n">d_aic_ak</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">aicc</span> <span class="o">-</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">aicc</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="c1"># Calculate AICc weights</span>
            <span class="n">w_aic_ak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_aic_ak</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_aic_ak</span><span class="p">))</span>
            <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;w_aic_ak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_aic_ak</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_aic_ak</span><span class="p">)</span>

            <span class="c1"># Calculate cum. AICc weights</span>
            <span class="n">aiccs</span><span class="p">[</span><span class="s1">&#39;cum_w_ak&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">w_aic_ak</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

            <span class="c1"># Find index where the cum weights above p-val</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aiccs</span><span class="p">[</span><span class="n">aiccs</span><span class="o">.</span><span class="n">cum_w_ak</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Get bw boundaries</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">aiccs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">aiccs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">intervals</span> <span class="o">+=</span> <span class="p">[</span><span class="n">interval</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intervals</span>

    <span class="k">def</span> <span class="nf">local_collinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes several indicators of multicollinearity within a geographically</span>
<span class="sd">        weighted design matrix, including:</span>

<span class="sd">        local condition number (n, 1)</span>
<span class="sd">        local variance-decomposition proportions (n, p)</span>

<span class="sd">        Returns four arrays with the order and dimensions listed above where n</span>
<span class="sd">        is the number of locations used as calibrations points and p is the</span>
<span class="sd">        nubmer of explanatory variables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span>
        <span class="n">nvar</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">vdp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span><span class="p">))</span>
        <span class="n">vdp_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span> <span class="n">nvar</span><span class="p">,</span> <span class="n">nvar</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">):</span>
            <span class="n">xw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nvar</span><span class="p">):</span>
                <span class="n">wi</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
                <span class="n">wi</span> <span class="o">=</span> <span class="n">wi</span> <span class="o">/</span> <span class="n">sw</span>
                <span class="n">xw</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">wi</span>

            <span class="n">sxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xw</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">sxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">xw</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">sxw</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nvar</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">svdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">sxw</span><span class="p">)</span>
            <span class="n">vdp_idx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">svdx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">svdx</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">phi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">pi_ij</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vdp_pi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pi_ij</span>

        <span class="n">local_CN</span> <span class="o">=</span> <span class="n">vdp_idx</span><span class="p">[:,</span> <span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">VDP</span> <span class="o">=</span> <span class="n">vdp_pi</span><span class="p">[:,</span> <span class="n">nvar</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">local_CN</span><span class="p">,</span> <span class="n">VDP</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spatial_variability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">n_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to compute a Monte Carlo test of spatial variability for each</span>
<span class="sd">        estimated coefficient surface.</span>

<span class="sd">        WARNING: This test is very computationally demanding!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        selector        : sel_bw object</span>
<span class="sd">                          should be the sel_bw object used to select a bandwidth</span>
<span class="sd">                          for the gwr model that produced the surfaces that are</span>
<span class="sd">                          being tested for spatial variation</span>

<span class="sd">        n_iters         : int</span>
<span class="sd">                          the number of Monte Carlo iterations to include for</span>
<span class="sd">                          the tests of spatial variability.</span>

<span class="sd">        seed            : int</span>
<span class="sd">                          optional parameter to select a custom seed to ensure</span>
<span class="sd">                          stochastic results are replicable. Default is none</span>
<span class="sd">                          which automatically sets the seed to 5536</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        p values        : list</span>
<span class="sd">                          a list of psuedo p-values that correspond to the model</span>
<span class="sd">                          parameter surfaces. Allows us to assess the</span>
<span class="sd">                          probability of obtaining the observed spatial</span>
<span class="sd">                          variation of a given surface by random chance.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">temp_sel</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">5536</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">search_params</span> <span class="o">=</span> <span class="n">temp_sel</span><span class="o">.</span><span class="n">search_params</span>

        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">constant</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>

        <span class="n">init_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">SDs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># if they have it, let users have a progress bar</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>  <span class="c1"># otherwise, just passthrough the range</span>
                <span class="k">return</span> <span class="n">x</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_iters</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Testing&#39;</span><span class="p">):</span>
            <span class="n">temp_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">temp_sel</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">temp_coords</span>
            <span class="n">temp_sel</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="o">**</span><span class="n">search_params</span><span class="p">)</span>
            <span class="n">temp_params</span> <span class="o">=</span> <span class="n">temp_sel</span><span class="o">.</span><span class="n">params</span>
            <span class="n">temp_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">temp_params</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">SDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_sd</span><span class="p">)</span>

        <span class="n">p_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SDs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">init_sd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_iters</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">p_vals</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print out MGWR summary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        as_str        : bool</span>
<span class="sd">                        optional parameters to specify that summary results</span>
<span class="sd">                        should be returned as str and not printed to stdout</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        summary        : Optional[str]</span>
<span class="sd">                        optional MGWR summary string if `as_str` is True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="n">summaryModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">summaryGLM</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">summaryMGWR</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">summary</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.0.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>